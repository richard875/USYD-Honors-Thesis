\chapter{Discussion} \label{chap:discussion}

After completing the experiment and collecting the result, we would like to review and revisit the procedure, including the experiment setup, execution and analysis of the result data. The experiment largely did not align with the initial hypothesis and assumption: Spin outperforms Flask. Instead, we got the opposite result. Nonetheless, the result was interesting because it made us wonder why Spin did not outperform Flask. Although WebAssembly has shown great potential in its performance throughout its usage in frontend development, we will provide our own verdict on if it is ready to be adopted widely for backend usage, especially within the commercial sector.

We did see areas where WebAssembly performed well. For example, in bucket sorting in the first stage of the experiment, WebAssembly showcased its ability for system memory management. And thus, it outperformed Flask on that particular benchmarking algorithm. We also discovered in the investigation that WebAssembly performed better the larger the input data size, again showcasing that WebAssembly is able to work better with system memory than the traditional implementation. This also aligns with the previous research conducted by Gadepalli et al. (2020) \cite{lit34}.

We list out a few reasons for WebAssembly failed to outperform traditional frameworks. Firstly, the setup. Although \textbf{Amazon Web Service (AWS)} is getting more advanced and powerful every day. It does not have an official way to deploy WebAssembly Applications efficiently. Therefore, we had to use the Amazon EC2 virtual machine service for our experiment for both applications. Furthermore, we used Docker to Containerise our applications. Both procedures add unnecessary overhead to the WebAssembly framework. However, from earlier research and literature reviews, we knew that the main issue with the containerised application is the cold start speed. However, this is a relatively minor concern in our experiment, as our primary goal is to benchmark the calculation ability for both frameworks.

Secondly, we conducted our benchmarking experiment with the Python language. The reason we used Python to conduct the experiment is that Python has the most comprehensive sorting algorithm collections available. In addition, Python is also one of the most popular languages used within the industry. Therefore, it will likely be continuously used across the industry to build new applications with the WebAssembly framework solutions.

Throughout our experiment, from the development of the benchmarking application to local testing, all the way to the deployment of the solution, we constantly noticed that the Spin WebAssembly solution had a worse development experience and a slower runtime than the traditional Flask solution. Thus, WebAssembly has consistently shown its potential within the frontend web development industry and was endorsed by large technology corporations such as \textbf{Adobe} and \textbf{Google}. We believe that it is currently not ready for production development in the backend framework industry, especially within the commercial market. This is also pointed out by the developers of the current WebAssembly backend solutions. For example, Fermyon (Developer for Spin framework) and the Wasmcloud team. However, considering the technology was first made available in 2019 with the release of \textbf{WASI (WebAssembly System Interface)}, it has made considerable progress in only a few years. Thus, continuing with the current development rate, we can see the huge potential of the WebAssembly backend solution running on the edge.

Continuing from what we uncovered during the experiment, we propose a few possible areas for further research. Firstly, we discovered that the performance gap between the WebAssembly solution and the traditional Flask solution decreases when the input data size increases. Thus, we propose to expand our existing experiment, potentially adding support to our current benchmarking applications to accept larger input data. After that, re-run the experiment procedure.

Secondly, we propose to re-implement our experiment with a high-performance programming language, such as \textbf{Go} or \textbf{Rust}, at the same time keeping the current deployment procedure. Recently, languages such as Rust have gained considerable popularity along with the rise of WebAssembly. Although Python continues to remain one of the most popular programming languages, developers and researchers have gradually switched to the Go and Rust programming language for server-side WebAssembly solution development. Thus, it is worth re-conducting our experiment with a high-performing language to further solidify our current discoveries from the experiments in this thesis.