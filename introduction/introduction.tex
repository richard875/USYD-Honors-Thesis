\chapter{Introduction}

Almost everyone uses the internet every day, whether connecting to the internet from their mobile devices or browsing the internet on their personal computers. It is safe to say that most of us will struggle with everyday activities without internet communication devices. For example, getting a taxi ride, ordering food delivery or even navigating to places we want to go. Apple made an interesting short movie "predicting" what might happen without Apps on mobile devices during their annual Worldwide Developers Conference (WWDC) in 2017 [15].
 
The Internet has an even greater presents and role within the science and engineering community, sites like Google Scholar and The New England Journal of Medicine have benefited scientists, doctors and engineers greatly [15] [16] [17]. Prior to the wide adaption of the internet, researchers, scholars and students would spend countless hours in physical libraries, browsing through hundreds of academic journals and books in order to answer one question or to solidify a proposal they had in mind. Today, with the help of the internet, it will hardly take a few minutes. This leads to the jump in research productivity which helps researchers and engineers to produce their research and production output to a new level, thus allowing them to essentially do more things with the same amount of time.

\bigskip
\bigskip

\textbf{{\Large Chapter 1.1 Introduction to JavaScript and the history of the web}}

\bigskip

For the last 20 years, JavaScript is the technology that dominates the majority of web browsers and the web development industry. Although updates and new versions are issued regularly, they are still becoming more aged every day, and software engineers have been finding ways to improve the runtime performance, user experience and developer experience of this ageing technology. For example, Microsoft developed the Typescript language to combat the "strange" nature of the JavaScript language and to help resolve the lack of type checking within JavaScript [18] [19]. Facebook developed the "React" library framework to improve the developer experience by introducing the "component" concept. Where each class or function within a React project can be seen as a UI (user interface) component. This can be a button, a table or a component with more complexity, such as a navigation header component [20]. As expected and intended, some of the popular web development frameworks and libraries such as React JS and Angular developed by Google have gained significant attention and much of the industry-wide adaption since their release and they have indeed significantly improved the browsing experience for all of us.

There is a widespread misconception that Al Gore, the Former Vice President of the United States, invented the internet. However, this is not true as Al Gore has never claimed or said so. Instead, what he actually said was "I took the \textbf{initiative} in creating the internet" during his interview with CNN in 1999 [22]. However, Al Gore did introduce the High Performance Computing Act of 1991 [23], which help fund the creation of the first mainstream web browser Mosaic [24], as well as the creation of the high-speed fibre optic computer network [25].

JavaScript was born not long after the release of the first version of Netscape Navigator - the most popular web browser in the late 90s. It was written by Brendan Eich and it only took him 10 days to release the very first version [26]. Initially, JavaScript did not gain that much attention, and it wasn't until the release of Internet Explorer version 3 which added support for the language. After that, the popularity of JavaScript increased dramatically among the general public [27] [28]. Growing up alongside the internet, JavaScript has been through quite a number of iterations and feature upgrades. Although it is indeed powerful and popular, however, in recent years, developers and engineers started to see JavaScript as a "messy" language [figure \ref{fig:javascript_meme}]. During this period, another popular web technology - Adobe flash player, was gradually being replaced by its newer counterpart - HTML 5. This is largely due to its performance and security issues [30]. Between 2011 and 2021, the percentage of websites using Flash dropped from 28.5 per cent to just 2.2 per cent. Adobe alongside popular web browsers formally ended the support and update for Flash in 2021 [32].

A major change was just around the corner.

Developers and major tech companies started forming the future of the web. They wanted a new technology standard that aligned with the current web application development trend as well as laying the groundwork for the future of the industry. After much discussion, they came up with the idea of creating a brand new language based on all the experiences and mistakes from the last 20 years. Therefore, in 2017, we were introduced to the WebAssembly language.

\bigskip
\begin{figure}[hp]
\centering
\includegraphics[scale=0.7]{javascript_meme}
\caption{\footnotesize{Internet "meme" about the JavaScript language.}}
\captionsetup{aboveskip=0pt,font=it}
\label{fig:javascript_meme}
\end{figure}
\bigskip

\textbf{{\Large Chapter 1.2 Meet WebAssembly}}
\bigskip

After its initial release in 2017, WebAssembly was first adapted by a number of major web browsers [21]. Since then, there has been a growing community built around the technology as more and more projects started using WebAssembly. As mentioned above, JavaScript has been the de facto language for web browsers since the beginning of the web. However, this was never the original intention during the development of JavaScript.

WebAssembly is the first widely adopted language that was built entirely from the ground up with formal semantics, and it was designed to work in areas it originally intended, which are large, complex interactive applications running on modern web browsers. It has an incredibly clean, simple yet powerful design such as memory allocation and garbage collection [21]. However, WebAssembly is actually a form of binary code. Developers and engineers don't usually write WASM code directly, instead, they write programs with other low-level languages such as c, c++ or rust which will then be compiled down to WebAssembly code [29].

One of the biggest advantages of WebAssembly is standardisation. That is the ability to compile a wide variety of different programming languages down to just one, which can be very useful in a number of different scenarios. The industry term of this practice is called \textbf{polyglot} and it is largely missing from today's software development practices [76]. As an example, Java and Python developers cannot work on the same piece of software together because the code compilation method is different between the two languages. However, when it comes to developing WebAssembly programs, developers from all programming backgrounds now have the ability to work together and contribute to the same piece of software using languages they are comfortable with. One good example of this method is Microsoft's ASP.NET framework. ASP.NET, sometimes also referred to as the .NET framework family, was one of the first consumer-facing web frameworks for building web applications, it was released in 2002 alongside the release of the Visual Basic programming language [31] [32].

The VB language was popular for a time in the early 2000s, however, after a few years of its initial release, engineers at Microsoft are have decided to switch their primary language for .NET development from VB to C\#, due to C\# being an elegant language with the modern syntax [33]. However, instead of suddenly ending the support for Visual Basic language, they developed new versions of the .NET runtime to support and run a mixture of both languages [35]. This way, not only developers that use different languages can work together. But more importantly, big, latency applications can be continuously developed to extend their service life.

\bigskip
\begin{figure}[hp]
\centering
\includegraphics[scale=0.5]{C-to-VBNET-code-conversion-C-source-code-VBNET-source-code}
\caption{\footnotesize{Syntax between C\# (left) and VB (right) [34]}}
\captionsetup{aboveskip=0pt,font=it}
\end{figure}
\bigskip

\textbf{{\Large Chapter 1.3 Use cases of WebAssembly}}
\bigskip

As we mentioned above, since 2017, the four biggest web browsers have all been developed to compile and render WebAssembly out-of-the-box. And since then, the popularity of WebAssembly in front-end website development has increased dramatically. However, in this thesis, we will be looking into and conducting research and study on one of the latest use cases of WebAssembly - server-side WebAssembly development.

The modern, well-loved features of WebAssembly, combined with the release of the WebAssembly system interface made it all possible to move WebAssembly outside of web browsers to be run on other environments. Soon, scientists and engineers formed the idea of building a WebAssembly runtime that allows it to run natively on popular operating systems such as Windows, Mac OS and Linux just like what Node.js runtime allowed JavaScript to achieve [39].

This is a considerable achievement for WebAssembly because by being able to write software and applications that can run natively on operating systems, we can unleash the true power of WebAssembly. Take Node.JS for example, before it was released, the developer experience for desktop applications wasn't up to standard and there are very few options to develop cross-platform desktop applications. However, soon after its release to the public, companies started to develop new applications with Node.JS frameworks or migrate their existing applications and services to Node.JS. Some of the most popular desktop applications used by many of us on a daily basis are written in Node.JS such as Slack, Zoom and WhatsApp [36] [37] [38].

For any new technology that wants to be successful, and to gain popularity among developers and engineers, it needs to outperform its competitors in some ways to convince the industry that it can be faster, more powerful, more reliable or easier to develop than the technology it's intending to replace. In the case of Node.JS, it provides a familiar development environment to web developers since it is built on top of Google's V8 browser rendering engine [58]. On top of that, it has an easier learning curve and it also performs better than most desktop application frameworks at the time, such as Windows Presentation Foundation (WPF), Universal Windows Platform (UWP) and Java Swing [40] [41] [42].

\newpage
\bigskip
\begin{figure}[hp]
\centering
\includegraphics[scale=0.3]{electron-trend}
\caption{\footnotesize{Increase in popularity of the Electron framework since released in 2013}}
\captionsetup{aboveskip=0pt,font=it}
\end{figure}
\bigskip

Similarly, WebAssembly running on a native OS is intended to improve on the existing Node.JS solution to deliver an even better experience for both users and developers. One of the biggest challenges for Node.JS applications is the amount of memory it uses [43]. Although fast and agile, Node.JS applications and the Google Chrome browser have been long criticised for their intense memory usage [44]. In fact, a recent study showed that Google Chrome uses 10 times more memory than Apple's Safari browser when running natively on macOS Big Sur operating system [46] [47].

\newpage

\bigskip
\begin{figure}[hp]
\centering
\includegraphics[scale=0.4]{chrome-safari-ram-test}
\caption{\footnotesize{Safari vs. Chrome on memory and CPU usage comparison 1 (VM)}}
\captionsetup{aboveskip=0pt,font=it}
\end{figure}
\bigskip

\bigskip
\begin{figure}[hp]
\centering
\includegraphics[scale=0.4]{chrome-safari-RAM-2}
\caption{\footnotesize{Safari vs. Chrome on memory and CPU usage comparison 2 (Native)}}
\captionsetup{aboveskip=0pt,font=it}
\end{figure}
\bigskip

As we see in the above figures, with only two browser tabs open, Google Chrome already used 1 GB of memory, and when running 54 tabs, Google Chrome uses 24 times more memory than Safari.

Issues like this are exactly what WebAssembly is intended to tackle and resolve. Benchmark testing shows that when comparing the download size and memory usage between Electron Node.JS and Microsoft's Blazor WebAssembly desktop applications, Node.JS can be up to 82.5 times larger in terms of download size and uses 7.9 times more memory than its WebAssembly counterpart [48].

\bigskip
\begin{figure}[hp]
\centering
\includegraphics[scale=0.9]{download-size-chart}
\caption{\footnotesize{Electron vs. Blazor on package size comparison}}
\captionsetup{aboveskip=0pt,font=it}
\end{figure}
\bigskip

\bigskip
\begin{figure}[hp]
\centering
\includegraphics[scale=0.9]{memory-use-chart}
\caption{\footnotesize{Electron vs. Blazor on memory usage comparison}}
\captionsetup{aboveskip=0pt,font=it}
\end{figure}
\bigskip

\textbf{{\Large Chapter 1.4 Outline of the Thesis}}
\bigskip

In this thesis, we will be conducting studies and investigations on the performance gap and inconsistency between applications running with VM/Containers in the cloud and applications built with WebAssembly frameworks running on the edge. We will be uncovering the pros and cons of this new way of developing cutting-edge, low-latency applications, and finally, we will undertake our own experiment with the two frameworks of our choice. And finally, deliver our own verdict on the current state of WebAssembly running on the edge for commercial use.

In \textbf{Chapter 2}, we will provide a detailed literature review on related background work, including research and study that has already been done within this area as well as looking at the proposed further studies. In \textbf{Chapter 3}, we will formally introduce our experiment, including the overview, procedure and expected outcome. After that in \textbf{Chapter 4}, we will formally conduct the experiment to compare and study the difference in performance and behaviour of the two frameworks of our choice. We will present the result and findings in \textbf{Chapter 5}. After that, we will provide our own verdict on the experiment outcome through a discussion in \textbf{Chapter 6}. Finally, we will summarise the experiment and our findings within the experiment, provide suggestions on further research, and deliver final remarks.